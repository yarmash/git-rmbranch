#!/usr/bin/env python3

import argparse
import re
import subprocess
import sys


def get_default_branch():
    """Get the repo's default branch (master or main)"""

    for branch_name in ('master', 'main'):
        if subprocess.run(['git', 'show-ref', '--verify', '--quiet', f'refs/heads/{branch_name}']).returncode == 0:
            return branch_name
    raise RuntimeError('Unable to determine the default branch for the repo')


def get_upstream(branch_name):
    """Get upstream information for a local branch from config"""
    result = subprocess.run(
        ['git', 'config', '--get-regexp', fr'^branch\.{re.escape(branch_name)}\.'],
        capture_output=True, text=True)

    if result.returncode != 0:
        return None

    upstream = {}
    offset = len(f'branch.{branch_name}.')

    for line in result.stdout.splitlines():
        key, value = line.split()
        key = key[offset:]
        assert key not in upstream, f"Multiple values for 'branch.{branch_name}.{key}'"
        upstream[key] = value

    return upstream


def get_current_branch():
    """Get the current branch name"""

    return subprocess.run(
        ['git', 'branch', '--show-current'],
        capture_output=True, check=True, text=True
    ).stdout.rstrip()


def main():
    args = parse_args()

    current_branch = get_current_branch()

    if args.branch_name == current_branch:
        print(f"Branch '{args.branch_name}' is the current branch.")
    elif args.branch_name == '.':
        args.branch_name = current_branch

    if args.branch_name == current_branch:
        default_branch = get_default_branch()  # TODO: consider just using '-' (previous branch)
        new_branch = input(f'Enter a new branch name to checkout ({default_branch}): ').strip()
        if not new_branch:
            new_branch = default_branch
        result = subprocess.run(['git', 'checkout', new_branch])
        if result.returncode != 0:
            return result.returncode

    upstream = get_upstream(args.branch_name)

    result = subprocess.run(['git', 'branch', '-D', args.branch_name],
                            capture_output=True, text=True)
    if result.returncode != 0:
        print(result.stderr, end='')
        return result.returncode

    sha = re.search(r'\(was (\w+)\)', result.stdout)[1]
    print(result.stdout.rstrip(),
          f"To restore, run 'git branch {args.branch_name} {sha}'.")

    if upstream is None:
        print(f"No upstream configured for the branch '{args.branch_name}'.")
        return 0

    print(f"Deleting '{upstream['merge']}' from '{upstream['remote']}'..")

    # this command also removes the local remote-tracking branch
    return subprocess.run(
        ['git', 'push', upstream['remote'], '--delete', upstream['merge']],
        timeout=30
    ).returncode


def parse_args():
    parser = argparse.ArgumentParser(description='Delete a Git branch locally and remotely.')
    parser.add_argument('branch_name', help='The branch name')
    return parser.parse_args()


if __name__ == '__main__':
    sys.exit(main())
